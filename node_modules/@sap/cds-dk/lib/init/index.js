const path = require('path');

const { defaultLogger } = require('./util/logger');
const FsUtil = require('./util/fsUtil');
const term = require('../util/term');

const CMD_INIT = 'init';
const CMD_ADD = 'add';

const { OPTION_HANA, OPTION_JAVA, OPTION_MTA, OPTION_NODEJS, OPTION_PIPELINE, OPTION_SAMPLES,
    PROJECT_FILES, REGEX_PROJECT_NAME } = require('./constants');

module.exports = class CDSGenerator {
    constructor(fsUtil, logger) {
        this.fsUtil = fsUtil || new FsUtil();
        this.logger = logger || defaultLogger;

        this.uiConfig = [
            {
                title: `Project Name`,
                description: `Enter your project name.`,
                default: '',
                target: 'projectName',
                validate: async (value) => {
                    try {
                        await this._validateProjectName(value);
                        await this._validateProjectFolder(path.join(process.cwd(), value), process.cwd());

                        return true;
                    } catch (err) {
                        return err.message;
                    }
                },
                guiOptions: {
                    hint: 'This name is restricted to certain characters. A valid project name is compatible across platforms.',
                    mandatory: true
                }
            },
            {
                title: `Type`,
                description: `Select your runtime.`,
                default: OPTION_NODEJS,
                choices: [
                    { name: 'Node.js', value: OPTION_NODEJS },
                    { name: 'Java', value: OPTION_JAVA }
                ],
                multiple: false,
                target: 'add',
                guiOptions: {
                    hint: `The preferred runtime can't be changed afterwards. To use a different runtime, create a new project.`,
                    mandatory: true
                }
            },
            {
                title: `Features`,
                description: `Add features to your project.`,
                default: '',
                choices: [
                    { name: 'CI/CD Pipeline Integration', value: OPTION_PIPELINE },
                    { name: 'Configuration for SAP HANA Deployment', value: OPTION_HANA },
                    { name: 'MTA based SAP Cloud Platform Deployment', value: OPTION_MTA }
                ],
                multiple: true,
                target: 'add',
                guiOptions: {
                    hint: `Choose any combination of features enriching the capabilities of your project. You can also add features later with ${term.bold('cds add')}`
                }
            },
            {
                title: `Samples`,
                description: `Add sample content to your project.`,
                default: '',
                choices: [
                    { name: 'Basic Sample Files', value: OPTION_SAMPLES }
                ],
                multiple: true,
                target: 'add',
                guiOptions: {
                    hint: 'Speed up your ramp-up phase with some sample files in your project.'
                }
            }
        ]

        // legacy handling for generator-cap-project < 3.0
        // does not contain OPTION_NODJES since old Yeoman generator
        // cannot handle types correctly
        this.config = {
            add: {
                title: `Features`,
                description: `Select the features for the new project.`,
                default: '',
                choices: [OPTION_HANA, OPTION_JAVA, OPTION_MTA, OPTION_PIPELINE, OPTION_SAMPLES],
                multiple: true,
                promptOrder: 10 // used to identify ui prompts
            },
            force: {
                default: false
            }
        }
    }

    /**
     * @param {string} templates, comma separated list of templates, no blanks
     * @param {any} options, additional options
     */
    async addCmd(templates, options = {}) {
        options._cmd = CMD_ADD;
        options.add = templates;

        this._initialize(null, options);
        this._greetings(options._cmd);

        if (!(await this._findProjectFile(this.projectPath))) {
            throw new Error(`The current folder doesn't seem to contain a project. None of the following files found: ${PROJECT_FILES.join(', ')}.`);
        }

        if (options.add.has(OPTION_JAVA) || options.add.has(OPTION_NODEJS)) {
            throw new Error(`You can't change the type of an existing project.`);
        }

        await this._process(options);
        await this.stepEnd(options);
    }

    /**
     * @param {string} projectName, the project name
     * @param {any} options, additional options
     */
    async initCmd(projectName, options = {}) {
        await this.stepInit(projectName, options);
        await this.stepEnd();
    }

    async stepInit(projectName, options = {}) {
        options._cmd = CMD_INIT;

        this._initialize(projectName, options);
        this._greetings(options._cmd);

        await this._process();
    }

    async _findProjectFile(projectPath) {
        for (const file of PROJECT_FILES) {
            if (await this.fsUtil.pathExists(path.join(projectPath, file))) {
                return file;
            }
        }

        return null;
    }

    _initialize(projectName, options = {}) {
        // deprecated, only for compatibility
        if (options.verbose) {
            process.env.DEBUG = true;
        }

        this.cwd = options.cwd || process.cwd();
        this.projectPath = path.resolve(this.cwd, projectName || '.');
        this.projectName = path.basename(this.projectPath);

        this.options = options;
        this._cleanupOptions();
    }

    _greetings(cmd) {
        switch (cmd) {
            case CMD_INIT: {
                const relativeProjectPath = path.relative(this.cwd, this.projectPath);
                const folderName = (relativeProjectPath ? `.${path.sep}${relativeProjectPath}` : 'current folder');
                this.logger.log(`[cds] - creating new project in ${folderName}`);
                break;
            }

            case CMD_ADD:
                this.logger.log(`[cds] - adding feature(s) to project in current folder`);
                break;

            default:
        }

        if (this.options.force) {
            this.logger.log(`[cds] - using '--force' ... existing files will be overwritten...!`);
        }
    }

    async _process() {
        this.logger.debug(`Project path: ${this.projectPath}`);

        await this._validateOptions();
        await this._fillTemplateList();

        for (const template of this.templateList) {
            this.logger.log(`[cds] > adding feature '${template.name}'...`);
            await template.run();
        }

        this.logger.log(`[cds] - done.`);
        this.logger.log();
    }

    async _fillTemplateList() {
        this.templateList = [];

        for (const addOption of this.options.add) {
            let Template;
            try {
                Template = require(`./template/${addOption}`);
            } catch (err) {
                throw new Error(`feature '${addOption}' not found. ${err}`);
            }
            const template = new Template(this.projectPath, this);
            this.templateList.push(template);
        }

        this.templateList.sort((a, b) => {
            const prioA = a.getPriority();
            const prioB = b.getPriority();
            return prioB - prioA;
        });

        const newList = [];
        for (const template of this.templateList) {
            // checkEnabled might throw error if call is invalid to abort execution
            this.logger.debug(`Checking feature '${template.name}'`);
            if (await template.checkEnabled()) {
                this.logger.debug(`Adding feature '${template.name}'`);
                newList.push(template);
            }
        }
        this.templateList = newList;

        // check debug to avoid lengthy computation when not debug
        if (process.env.DEBUG) {
            this.logger.debug(`Features: ${this.templateList.map((obj) => {
                return obj.name;
            }).join(', ')}`);
        }
    }

    async stepEnd() {
        if (process.env.DEBUG) {
            this._showFiles();
        }

        for (const template of this.templateList) {
            await template.finalize();
        }
    }

    _showFiles() {
        const files = this.fsUtil.getTouchedFiles();
        if (files && files.length > 0) {
            this.logger.log(`[cds] - added / changed files`);
            for (const file of files) {
                this.logger.log(`[cds] - ${file}`);
            }
            this.logger.log();
        }
    }

    _cleanupOptions() {
        let tokens = [];

        if (typeof this.options.add === 'string') {
            tokens = this.options.add.split(/[,\s]/);

        } else if (Array.isArray(this.options.add)) {
            tokens = this.options.add

        } else if (this.options.add instanceof Set) {
            tokens = [...this.options.add];
        }

        const trimmedTokens = tokens.map((token) => {
            return token.trim();
        }).filter((token) => {
            return !!token;
        });

        // set is ordered ... always
        this.options.add = new Set(trimmedTokens);

        if (this.options._cmd === CMD_INIT && !this.options.add.has(OPTION_JAVA)) {
            this.options.add.add(OPTION_NODEJS);
        }
    }

    async _validateOptions() {
        if (this.options.add.has(OPTION_JAVA) && this.options.add.has(OPTION_NODEJS)) {
            throw new Error(`Only one runtime per project is supported. Specify either ${OPTION_JAVA} or ${OPTION_NODEJS}.`);
        }

        if (this.options.force) {
            return;
        }

        if (this.options._cmd === CMD_INIT) {
            await this._validateProjectName(this.projectName);
            await this._validateProjectFolder(this.projectPath, this.cwd);
        }
    }

    async _validateProjectName(projectName) {
        if (!projectName) {
            throw new Error('Specify a project name.');
        }

        // remove duplicates by using a set
        const invalidChars = new Set(projectName.match(REGEX_PROJECT_NAME));
        switch (invalidChars.size) {
            case 0:
                break;
            case 1:
                throw new Error(`Project name ${projectName} contains an invalid character (${[...invalidChars].join(', ')}). Specify a different project name.`);
            default:
                throw new Error(`Project name ${projectName} contains invalid characters (${[...invalidChars].join(', ')}). Specify a different project name.`);
        }
    }

    async _validateProjectFolder(projectPath, cwd) {
        const existingProjectFile = await this._findProjectFile(projectPath);
        if (existingProjectFile) {
            let message;
            if (cwd === projectPath) {
                message = `You seem to be working in a project which is already initialized. Use ${term.bold('cds add')} to add more features.`;
            } else {
                message = `You seem to be trying to initialize an existing project. Use a different project name instead.`;
            }
            throw new Error(`${message}\nDetails: File '${existingProjectFile}' exists in the project folder which indicates an existing project. Use ${term.bold('cds add')} to add more features.`);
        }
    }
}
