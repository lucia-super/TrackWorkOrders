module.exports = Object.assign ( _import, { _name:'import',
    options: ['--out'],
    flags:[ '--dry', '--no-copy', '--no-save', '--keep-namespace' ],
    shortcuts: ['-o','-'],
    help: `
# SYNOPSIS

    *cds import* <source> [<options>]

    Imports the given source and converts it to CSN.
    Currently only OData EDMX input is supported.

    Without any options the source is copied to ./srv/external and the csn
    output written next to it. Finally it will add an entry for the imported
    service to package.json#cds.requires.


# OPTIONS

    *--no-copy*
        Skips copying to ./srv/external.

    *--no-save*
        Skips updating ./package.json.

    *--keep-namespace*
        Keeps the original namespace from the edmx content instead of using
        the filename by default.

    *-o | --out* <filename>
        Skips copying to ./srv/external and writes to the specified location.

    *- | --dry*
        Writes the converted csn to stdout only.


# EXAMPLES

    cds import ~/Downloads/API_BUSINESS_PARNTER.edmx
    cds import - ~/Downloads/API_BUSINESS_PARNTER.edmx

`})

// const edm2csn = require('@sap/edm-converters/lib/edmToCsn/lib/main')
const cds = require ('@sap/cds')
const fs = cds.utils, {path,isfile} = fs

async function _import (file, { out, dry,
    'no-save':no_save,
    'no-copy':no_copy,
    'keep-namespace':keep_namespace
}={}) {
    if (Array.isArray(file)) file = file[0]
    if (!file)  return this.help ('import')
    const fileResolved = isfile (path.resolve(file))
    if (!fileResolved)  {
      console.error (`\n  No such file: ${file}\n`); return process.exitCode = 1
    } else file = fileResolved
    const external = path.resolve ('srv/external')
    const dst = path.join (external, path.basename(file))
    if (!dry && !no_copy) file = await _copy_to_srv_external (file,dst)
    const src = await _read (file)
    const csn = await _edmx2csn (src, !keep_namespace && file)
    const written = dry || _write (csn, out = out || dst.replace(/\.[^.]+$/,'.csn'))
    const registered = dry || no_save || _update_package_json (out, csn)
    if (dry)  return console.log (JSON.stringify(csn,0,'  '))
    return Promise.all ([ written, registered ])
}


async function _read (file) {
    if (!file && !process.stdin.isTTY) return new Promise ((_resolved, _error) => {
        let src=""; process.stdin
        .on ('data', chunk => src += chunk)
        .on ('end', ()=> _resolved (src))
        .on ('error', _error)
    })
    else return await fs.readFileSync (file, 'utf-8')
}


async function _write (csn, dest) {
    await fs.writeFileSync (dest, JSON.stringify(csn,null,'  '))
    const service = _service_name_from(csn)
    let using = `using { ${service} as external } from './${path.relative('srv',dest) .replace (/\\/g,'/')}';`
    using = require ('../lib/util/term').info (using)
    console.log(
`[cds] - imported API to ${path.relative(process.cwd(),dest)}
> use it in your CDS models through the like of:

${using}
`)}


async function _edmx2csn (edmx, filename) {
    const edm2csn = require ('@sap/edm-converters/lib/edmToCsn/lib/main')
    const TwoSchemas = /(\s*<\/Schema>\s*<Schema [^>]*>)\s*/m
    const result = edmx.match (/EntityType="([^.]+)/)
    if (!result)  throw new Error ('Not a valid EDMX document: '+filename)
    const [,namespace] = result
    if (TwoSchemas.test(edmx)) {
        /*
            This is a quick hack only handling the following case we saw from SFSF:

            <edmx:DataServices>
                <Schema Namespace="SFODataSet">
                    <EntityContainer>
                        <EntitySet Name="Foos" EntityType="SFOData.Foo"> ... </EntitySet>
                    </EntityContainer>
                </Schema>
                <Schema Namespace="SFOData">
                    <EntityType Name="Foo"> ... </EntityType>
                </Schema>
            </edmx:DataServices>

            which is turned into that:

            <edmx:DataServices>
                <Schema Namespace="SFOData">
                    <EntityContainer>
                        <EntitySet Name="Foos" EntityType="SFOData.Foo"> ... </EntitySet>
                    </EntityContainer>
                    <EntityType Name="Foo"> ... </EntityType>
                </Schema>
            </edmx:DataServices>
        */
        edmx = edmx.replace (TwoSchemas,'') .replace (/<Schema Namespace="[^"]+"/, `<Schema Namespace="${namespace}"`)
    }

    if (filename) {
        // Replace namespace by given filename...
        const re = RegExp(`"${namespace}([".])`,'g')
        const fn = `"${path.parse(filename).name}$1`
        edmx = edmx.replace (re,fn)
    }

    const csn = JSON.parse (await edm2csn.generateCSN (edmx, false, true))
    return csn
}


async function _copy_to_srv_external (file, dst) {
    const cwd = process.cwd()
    const dstDir = path.dirname (dst)
    if (!file.startsWith(dstDir+path.sep)) {
        await fs.mkdirp (dstDir)
        const copy_or_move = file.startsWith(cwd+path.sep) ? fs.renameSync : fs.copyFileSync
        copy_or_move (file,dst)
        return dst
    }
    return file
}


function _service_name_from (csn) {
    for (let each in csn.definitions) {
        if (csn.definitions[each].kind === 'service')  return each
    }
}

function _update_package_json (dest, csn) {
    try {
        const package_json = path.resolve ('package.json')
        const conf = fs.existsSync(package_json) ? require (package_json) : {}
        const service = _service_name_from(csn)
        const requires = ['cds','requires'] .reduce ((p,n)=>p[n] || (p[n]={}), conf)
        if (!requires[service]) {
            const model = path.relative(process.cwd(), dest.replace(/\.csn$/,'').replace (/\\/g,'/'))
            cds.env.requires[service] = requires[service] = { kind:'odata', model }
            fs.writeFileSync (package_json, JSON.stringify(conf,null,'  '))
            console.log (`[cds] - updated ./package.json`)
        }
    } catch(e){/* ignore */}
}
